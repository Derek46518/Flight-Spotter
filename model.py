# The following code is generated by ChatGPT
import pandas as pd
import numpy as np
from sklearn.preprocessing import StandardScaler
from sklearn.model_selection import train_test_split
import torch
import torch.nn as nn
from torch.utils.data import Dataset, DataLoader

# ========== 1. 讀取並清理資料 ==========
df = pd.read_csv("your_data.csv", header=None)

# 設定欄位名稱
columns = [
    "year","month","day","hour","minute","second","hex","flight","aircraft_type",
    "baro_altitude","geo_altitude","velocity","track","vertical_rate","squawk","pressure",
    "target_baro_altitude","target_geo_altitude","ground_distance","latitude","longitude",
    "hour_bin","direction","track2","unknown1","unknown2","mode"
]
df.columns = columns

# 選擇有效欄位（移除文字類欄位，保留數值類欄位）
numerical_cols = [
    "baro_altitude","geo_altitude","velocity","track","vertical_rate",
    "target_baro_altitude","target_geo_altitude","ground_distance",
    "latitude","longitude","track2"
]

# 時間欄位建立 datetime index
df["timestamp"] = pd.to_datetime(df[["year", "month", "day", "hour", "minute", "second"]])
df.sort_values(by=["hex", "timestamp"], inplace=True)

# ========== 2. 建立時間步序列 ==========
sequences = []
grouped = df.groupby("hex")

for _, group in grouped:
    if len(group) < 5: continue  # 保留較長的時間序列
    seq = group[numerical_cols].values
    sequences.append(seq)

# 補齊序列長度
MAX_LEN = max(len(seq) for seq in sequences)
for i in range(len(sequences)):
    pad_len = MAX_LEN - len(sequences[i])
    if pad_len > 0:
        sequences[i] = np.pad(sequences[i], ((0, pad_len), (0, 0)), mode='constant')

data_array = np.stack(sequences)  # (num_seq, seq_len, feature_dim)
print("序列形狀：", data_array.shape)  # e.g., (40, 20, 11)

# ========== 3. 特徵標準化 ==========
N, T, D = data_array.shape
scaler = StandardScaler()
data_array = scaler.fit_transform(data_array.reshape(-1, D)).reshape(N, T, D)

# ========== 4. 拆分訓練集與驗證集 ==========
train_X, val_X = train_test_split(data_array, test_size=0.2, random_state=42)

# 預測下個時間步：將 y 定義為右移一格
def shift_data(data):
    return data[:, 1:, :], data[:, :-1, :]  # y, x

train_y, train_x = shift_data(train_X)
val_y, val_x = shift_data(val_X)

# ========== 5. 自訂 Dataset ==========
class FlightDataset(Dataset):
    def __init__(self, x, y):
        self.x = torch.tensor(x, dtype=torch.float32)
        self.y = torch.tensor(y, dtype=torch.float32)

    def __len__(self):
        return self.x.shape[0]

    def __getitem__(self, idx):
        return self.x[idx], self.y[idx]

train_ds = FlightDataset(train_x, train_y)
val_ds = FlightDataset(val_x, val_y)
train_loader = DataLoader(train_ds, batch_size=8, shuffle=True)
val_loader = DataLoader(val_ds, batch_size=8)

# ========== 6. 建立 Transformer ==========
class TransformerModel(nn.Module):
    def __init__(self, feature_dim, embed_dim=64, num_heads=4, ff_dim=128, num_layers=2):
        super().__init__()
        self.embedding = nn.Linear(feature_dim, embed_dim)
        encoder_layer = nn.TransformerEncoderLayer(d_model=embed_dim, nhead=num_heads, dim_feedforward=ff_dim)
        self.encoder = nn.TransformerEncoder(encoder_layer, num_layers=num_layers)
        self.output = nn.Linear(embed_dim, feature_dim)

    def forward(self, x):
        x = self.embedding(x)  # (B, T, E)
        x = x.permute(1, 0, 2)  # -> (T, B, E)
        x = self.encoder(x)     # (T, B, E)
        x = x.permute(1, 0, 2)  # -> (B, T, E)
        out = self.output(x)    # (B, T, D)
        return out

# ========== 7. 訓練與評估 ==========
device = torch.device("cuda" if torch.cuda.is_available() else "cpu")
model = TransformerModel(feature_dim=D).to(device)
optimizer = torch.optim.Adam(model.parameters(), lr=1e-3)
criterion = nn.MSELoss()

EPOCHS = 20
for epoch in range(EPOCHS):
    model.train()
    total_loss = 0
    for x, y in train_loader:
        x, y = x.to(device), y.to(device)
        optimizer.zero_grad()
        y_pred = model(x)
        loss = criterion(y_pred, y)
        loss.backward()
        optimizer.step()
        total_loss += loss.item()

    model.eval()
    val_loss = 0
    with torch.no_grad():
        for x, y in val_loader:
            x, y = x.to(device), y.to(device)
            y_pred = model(x)
            loss = criterion(y_pred, y)
            val_loss += loss.item()
    print(f"Epoch {epoch+1} | Train Loss: {total_loss:.4f} | Val Loss: {val_loss:.4f}")
